\input texinfo  @c -*- coding: utf-8 -*-
@c %**start of header
@setfilename jdee.info
@settitle JDEE Manual
@c %**end of header

@documentencoding UTF-8

@titlepage
@title JDEE Manual
@page JDEE Manual
@end titlepage

@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top, User's Guide, (dir), (dir)
@top The Java Development Environment for Emacs (JDEE)

@end ifnottex

@menu
* User's Guide::
* Developer's Guide::
* Index::

@detailmenu
 --- The Detailed Node Listing ---

User's Guide

* Introduction::
* Registering and Selecting a JDK::
* Editing Java Source Files::
* Documenting Code::
* Abbreviations::
* Completing Expressions::
* Dynamic Keyword Completion::
* Generating Code::
* Checking Coding Style::

Introduction

* About::
* JDEE Requirements::
* Latest Version::
* Installing the JDEE::
* Reporting bugs::

Registering and Selecting a JDK

* Registering a JDK::
* Selecting a JDK::

Documenting Code

* Inserting Javadoc Comments::
* Generating the Documentation::

Abbreviations

* Keyword Abbreviations::
* Control Flow Abbreviations::

Control Flow Abbreviations

* Left Brace Placement::
* Customizing the Control Flow Templates::
* Adding Your Own Control Flow Templates::
* Enabling Variable Content::
* Disabling the Control Flow Abbreviations::

Completing Expressions

* Completing Method and Field Names::
* Selecting a Completion Method::
* Using Menu-Based Completion::
* Using In-Line Completion::
* Speeding Up Completion::

Dynamic Keyword Completion

* Dynamic Completion Commands::
* Electric Return::

Generating Code

* Generating Import Statements::
* Code Wizards::
* Code Templates::

Generating Import Statements

* Importing Classes::           Generate an import statement for the class at point
* Importing All Classes::       Generate import statements for all classes in the current buffer that need import statements
* Expanding Package Imports::   Expand a package import statement into specific class imports
* Collapsing Class Imports::    Collapse class imports into a package import statement
* Grouping Imports::            Group import statements
* Deleting Unneeded Imports::   Delete superfluous import statements

Code Wizards

* Method Override Wizard::
* Interface Wizard::
* Delegate Wizard::
* Get/Set Wizard::

Code Templates

* Buffer Templates::
* Specifying Boilerplate Text::
* Customization Variables::
* Point Templates::
* Customizing Templates::
* Creating Templates::
* Defining a Template and Template Insertion Function::
* Registering Custom Templates::
* Assigning Keys to Templates::

Developer's Guide

* JDEE Components::             Describes parts of JDEE

@end detailmenu
@end menu

@node User's Guide, Developer's Guide, Top, Top
@chapter User's Guide
Welcome to the JDEE User's Guide. This guide explains how to use the
JDEE to develop Java applications. The guide assumes that you are
familiar with Emacs, the Java programming language, and Java
development tools provided by Oracle.

@menu
* Introduction::
* Registering and Selecting a JDK::
* Editing Java Source Files::
* Documenting Code::
* Abbreviations::
* Completing Expressions::
* Dynamic Keyword Completion::
* Generating Code::
* Checking Coding Style::
@end menu

@node Introduction, Registering and Selecting a JDK, User's Guide, User's Guide
@section Introduction

@menu
* About::
* JDEE Requirements::
* Latest Version::
* Installing the JDEE::
* Reporting bugs::
@end menu

@node About, JDEE Requirements, Introduction, Introduction
@subsection About
The Java Development Environment for Emacs (@abbr{JDEE}) is an Emacs Lisp
package that interfaces Emacs to third-party Java application
development tools, such as those provided by Oracle as part of its
JDK. The result is an integrated development environment (@abbr{IDE})
comparable in power to many commercial Java IDEs. Features include:

@itemize
@item source code editing with syntax highlighting and auto indentation

@item automatic completion of class fields and methods

@item compilation with automatic jump from error messages to responsible line in the source code.

@item generates class and method skeletons automatically

@item run Java application in an interactive (comint) Emacs buffer

@item integrated debugging with interactive debug command buffer and automatic display of current source file/line when stepping through code

@item browse JDK doc, using the browser of your choice

@item browse your source code, using the Emacs etags facility or a tree-structured speedbar.

@item supports latest version of JDK

@item runs on any platform supported by Emacs and JDK (e.g., Linux, Windows and Solaris)

@item easily and infinitely customizable

@item works with FSF Emacs and XEmacs
@end itemize

@node JDEE Requirements, Latest Version, About, Introduction
@subsection JDEE Requirements
The JDEE requires the following software:
@itemize

@item
FSF Emacs or XEmacs on Unix platforms; the 23.4 or later version
of Emacs on Windows platforms, for general source file editing
and tool integration functions

@item
Java Development Kit (@abbr{JDK}) or compatible set of Java development tools
(compiler, virtual machine, debugger, class libraries, etc.)

@item
Web browser for viewing documentation

@item
Latest versions of Eric Ludlam's Speedbar, Semantic, and EIEIO
packages available for download from the CEDET home page

@item
The elib package available from the JDEE web site

@item
Bash or another Unix-style shell highly recommended for Windows
environments. The cygwin Unix emulation package for Windows from Red
Hat includes Bash
@end itemize

@node Latest Version, Installing the JDEE, JDEE Requirements, Introduction
@subsection Latest Version
See @uref{Downloading the JDEE} on the JDEE website for instructions
on downloading the most recent version of the JDEE.

@node Installing the JDEE, Reporting bugs, Latest Version, Introduction
@subsection Installing the JDEE
See the JDEE Installation Guide on the JDEE website for information on
installing the JDEE on your system.

@node Reporting bugs,  , Installing the JDEE, Introduction
@subsection Reporting bugs, enhancement suggestions
Please send bug reports and enhancement suggestions to
@email{jdee-users@@lists.sourceforge.net}.

@node Registering and Selecting a JDK, Editing Java Source Files, Introduction, User's Guide
@section Registering and Selecting a JDK

The JDEE relies on command-line Java development tools, such as those
supplied by Oracle as part of its Java Development Kit (JDK). Before
you can use the JDEE to compile, debug, or run an application, you
must tell it where the Java compiler, debugger, and virtual machine
are located on your system. The JDEE assumes that the compiler,
debugger, and vm are named javac, jdb, and java, respectively, and
that they are located on your system's command path. If these tools
are not located on the system command path or have different names,
you must tell the JDEE where they are located. The JDEE provides
customization variables for specifying the locations of individual
tools.

However, if you are using one or more versions of Oracle's JDK or a
clone of the JDK, the easiest way to specify the location of the
external development tools is to register the version of the JDK that
you intend to use. It is especially advantageous to register a JDK, if
you intend to use multiple versions of the JDK. The reason?
Registering each version of the JDK allows you to change JDKs by
changing a single customization variable. The following sections
explain how to register and select JDKs.

@menu
* Registering a JDK::
* Selecting a JDK::
@end menu

@node Registering a JDK, Selecting a JDK, Registering and Selecting a JDK, Registering and Selecting a JDK
@subsection Registering a JDK

To register a version of the JDK with the JDEE:

@enumerate
@item
Type M-x customize-variable RET jde-jdk-registry RET.

The jde-jdk-registry customization buffer appears.

@item
Click the INS button.

Enter the version number of the JDK and the path of the directory in
which the JDK is installed.

@item
Repeat the preceding steps until you have entered the versions and
paths of all versions of the JDK that you wish to use with the JDEE.

@item
Click the @samp{Save for Future Sessions} from the State menu.
This saves the setting of jde-jdk-registry in your init file.

@end enumerate

@node Selecting a JDK,  , Registering a JDK, Registering and Selecting a JDK
@subsection Selecting a JDK
To select a JDK:

@enumerate

@item
Type M-x customize-variable RET jde-jdk RET.

The jde-jdk customization buffer appears.

@item
The buffer lists the JDKs that you have previously registered
(@ref{Registering a JDK}).

@item
Click the radio button next to the version of the JDK you want to use.

@item
Click the @samp{Save for Future Sessions} from the State menu.
This saves the setting of jde-jdk-registry in your init file.

Note: This procedure saves your JDK selection in your init file so
that it applies to all projects. You can configure the JDEE to use different
JDKs for different projects by saving your customization in a project
file. (see Using Project Files) for more information.

@end enumerate

@node Editing Java Source Files, Documenting Code, Registering and Selecting a JDK, User's Guide
@section Editing Java Source Files

To edit an existing Java source file, load it into an Emacs buffer by
executing @kbd{C-x C-f}. Loading a Java source file into a buffer
causes the buffer to enter into jde-mode, a variant of java-mode,
which is in turn a variant of the standard Emacs cc-mode for editing
source files written in C and related languages. jde-mode offers all
the specialized source file editing commands of cc-mode plus functions
for creating, compiling, building, running, and debugging Java source
files. You can invoke the commands by selecting them from the JDE menu
that jde-mode displays on the Emacs menu bar or by typing the commands
in the Emacs minibuffer.

@node Documenting Code, Abbreviations, Editing Java Source Files, User's Guide
@section Documenting Code
The JDEE provides complete support for generating HTML documentation
for Java classes from comments inserted into the source code for those
classes.

See also Displaying Java Documentation.

@menu
* Inserting Javadoc Comments::
* Generating the Documentation::
@end menu

@node Inserting Javadoc Comments, Generating the Documentation, Documenting Code, Documenting Code
@subsection Inserting Javadoc Comments

To insert a skeleton javadoc comment for a class or method, position
point in the first line of the method or class and select
JDE->Document from the Emacs menubar or type @kbd{C-c C-v j}.

To customize the javadoc skeletons, select
JDE->Options->Project->Javadoc from the Emacs menubar.

Thanks to David Ponce for developing the JDEE's javadoc comment
generation facility.

@node Generating the Documentation,  , Inserting Javadoc Comments, Documenting Code
@subsection Generating the Documentation

To generate documentation for the current project, open any source
file in the project and select Make Doc from the JDE menu or enter M-x
jde-javadoc-make.

The jde-javadoc-make command runs the JDK's javadoc program to
generate the documentation. The javadoc command must be on your
system's command path.

The jde-javadoc-make command uses jde-global-classpath as the
-classpath and jde-sourcepath as the -sourcepath option for generating
the doc. You can specify all other javadoc options via JDEE
customization variables. To specify the options, select
Project->Options->Javadoc from the JDE menu. Use
jde-javadoc-gen-packages to specify the packages, classes, or source
files for which you want to generate javadoc. If this variable is nil,
the jde-javadoc-make generates javadoc for the Java source file in the
current buffer.

Thanks to Sergey A Klibanov for developing the JDEE's javadoc
generation facility.

@node Abbreviations, Completing Expressions, Documenting Code, User's Guide
@section Abbreviations

The JDEE allows you to use abbreviations for Java keywords and control
flow constructs. The following sections explain how to use these
abbreviations.

@menu
* Keyword Abbreviations::
* Control Flow Abbreviations::
@end menu

@node Keyword Abbreviations, Control Flow Abbreviations, Abbreviations, Abbreviations
@subsection Keyword Abbreviations

The JDEE defines a set of abbreviations for Java keywords. When you
type one of these abbreviations followed by a space in a Java source
buffer, the JDEE optionally expands the abbreviation into the
keyword. For example, when the abbreviation mode is enabled, you need
only type fa followed by a space to enter the Java keyword false.

To enable or disable abbreviation mode by default for a project,
select JDE->Project->Options ->General and toggle the boolean variable
jde-enable-abbrev-mode.

To toggle abbreviation mode on or off during a session, select
JDE->Code Generation->Modes->Abbrev.

To change, remove, or add an abbreviation, edit the variable
jde-mode-abbreviations in the project customization buffer.

@indentedblock
Note: The JDEE's Java keyword expansion facility is based on the Emacs
abbrev-mode facility. For more information, see the Emacs user
manual.
@end indentedblock

@node Control Flow Abbreviations,  , Keyword Abbreviations, Abbreviations
@subsection Control Flow Abbreviations

The JDEE defines abbreviations for Java control flow structures, such
as @code{if-then-else}. When you enter the abbreviation followed by a
space, the JDEE expands the abbreviation into a corresponding control
structure template.

Example: expanding the @code{if-then-else} abbreviation:

@example
ife
@end example

expands to the control flow structure:

@example
if ( ) @{ @} // end of if () else @} // end of if () else
@end example

The JDEE defines the following abbreviations for control structures:
@indentedblock
@multitable @columnfractions .70 .14
@headitem Statement @tab Abbreviation
@item if-then @tab if
@item else @tab else
@item if-then-else @tab ife
@item else-if @tab eif
@item while @tab while
@item for @tab for
@item for (int I=0;I<UL;I++) @tab fori
@item for (Iterator i = c.iterator(); i.hasNext();) @tab foriter
@item main method @tab main
@item switch @tab switch
@item case @tab case
@item try @tab try
@item catch @tab catch
@item try finally @tab tryf
@item finally @tab finally
@end multitable
@end indentedblock

@indentedblock
Note: You must enable the JDEE's Java keyword abbreviation mode to use
the control flow abbreviations. See Java Keyword Completion for more
information.
@end indentedblock

Thanks to Eric D. Friedman for contributing the control flow templates.

@menu
* Left Brace Placement::
* Customizing the Control Flow Templates::
* Adding Your Own Control Flow Templates::
* Enabling Variable Content::
* Disabling the Control Flow Abbreviations::
@end menu

@node Left Brace Placement, Customizing the Control Flow Templates, Control Flow Abbreviations, Control Flow Abbreviations
@subsubsection Left Brace Placement
The JDEE's Java control flow templates support two options for opening
brace placement: placement on the first line of the template
(Kerningham & Ritchie Style, the default) and placement on a separate
line.

Type M-x customize-variable jde-gen-k&r to specify the style you prefer.

@node Customizing the Control Flow Templates, Adding Your Own Control Flow Templates, Left Brace Placement, Control Flow Abbreviations
@subsubsection Customizing the Control Flow Templates
You can customize the templates to suit any indentation style. To
customize the templates, select Project->Options->Autocode from the
JDE menu.

@node Adding Your Own Control Flow Templates, Enabling Variable Content, Customizing the Control Flow Templates, Control Flow Abbreviations
@subsubsection Adding Your Own Control Flow Templates
Use the jde-gen-define-abbrev-template function to define your own
control flow abbreviation in your .emacs file. For example, the
following code defines an abbreviation for an else clause.

@example
(jde-gen-define-abbrev-template "melse" '('> "else @{" '> 'n
'> 'r 'n "@}"))
@end example

The jde-gen-define-abbrev-template function takes two arguments. The
first argument is a string that specifies the abbreviation. The
section argument is a list defining the text that replaces the
abbreviation. The list can contain any of the following elements.

Template Elements and their usage:

@table @asis
@item A string.
The string is inserted into the buffer at point.

@item The symbol 'p.
This position is saved in tempo-marks.

@item The symbol 'r.
If tempo-insert is called with ON-REGION non-nil the current region is
placed here. Otherwise it works like 'p.

@item (p PROMPT <NAME> <NOINSERT>)
If tempo-interactive is non-nil, the user is prompted in the minbuffer
with PROMPT for a string to be inserted. If the optional parameter
NAME is non-nil, the text is saved for later insertion with the s
tag. If there already is something saved under NAME that value is used
instead and no prompting is made. If NOINSERT is provided and non-nil,
nothing is inserted, but text is still saved when a NAME is
provided. For clarity, the symbol 'noinsert should be used as
argument.

@item (P PROMPT <NAME> <NOINSERT>)
Works just like the previous element, but forces tempo-interactive to
be true.

@item (r PROMPT <NAME> <NOINSERT>)
Like the previous, but if tempo-interactive is nil and tempo-insert is
called with ON-REGION non-nil, the current region is placed here. This
usually happens when you call the template function with a prefix
argument.

@item (s NAME)
Inserts text previously read with the (p ..) construct. Finds the
insertion saved under NAME and inserts it. Acts like 'p if
tempo-interactive is nil.

@item '&
If there is only whitespace between the line start and point, nothing
happens. Otherwise a newline is inserted.

@item '%
If there is only whitespace between point and end-of-line nothing
happens. Otherwise a newline is inserted.

@item 'n
Inserts a newline.

@item '>
The line is indented using indent-according-to-mode. Note that you
often should place this item after the text you want on the line.

@item 'n>
Inserts a newline and indents line.

@item 'r>
Like r, but it also indents the region.

@item 'o
Like '% but leaves the point before the new line.

@item Anything else.
It is evaluated and the result is treated as an element to be
inserted. One additional tag is useful for these cases. If an
expression returns a list '(l foo bar), the elements after 'l will be
inserted according to the usual rules. This makes it possible to
return several elements from one expression.
@end table

@node Enabling Variable Content, Disabling the Control Flow Abbreviations, Adding Your Own Control Flow Templates, Control Flow Abbreviations
@subsubsection Enabling Variable Content
Some templates optionally prompt you for items to insert into the
template. To enable prompting, set the variable tempo-interactive to a
non-nil value in your .emacs file.

@node Disabling the Control Flow Abbreviations,  , Enabling Variable Content, Control Flow Abbreviations
@subsubsection Disabling the Control Flow Abbreviations
To disable the control flow abbreviations, set the variable
jde-gen-cflow-enable off.

@node Completing Expressions, Dynamic Keyword Completion, Abbreviations, User's Guide
@section Completing Expressions

Both Emacs and the JDEE provide commands for completing incomplete
expressions. Emacs provides commands that work for any expression but
only if the completions exist in an open buffer. The JDEE provides
completion commands that work for any Java method or field name that
exists on jde-global-classpath. The following sections explain how to
use completion facilities supplied by the JDEE and by Emacs itself.

@menu
* Completing Method and Field Names::
* Selecting a Completion Method::
* Using Menu-Based Completion::
* Using In-Line Completion::
* Speeding Up Completion::
@end menu

@node Completing Method and Field Names, Selecting a Completion Method, Completing Expressions, Completing Expressions
@subsection Completing Method and Field Names

The JDEE provides comamnds that can complete an incomplete field or
method name. All the methods determine the set of possible completions
for an incomplete field or method name at point. They differ in how
they present the completions to you for selection. The commands
include:

@table @code
@item jde-complete-in-line
This command uses the first completion that it finds to complete the
method or field name at point. If multiple completions exist, it
allows you to cycle through the completions, each completion replacing
the previous in the source buffer. See Using In-Line Completion for
more information.

@item jde-complete-menu
This command displays a menu of possible completions for the
incomplete method or field name at point. It enters the completion
that you select in the source buffer. See Using Menu-Based Completion
for more information.

@item jde-complete-minibuf
This command uses the minibuffer to display possible completions for
the incomplete method or field name at point. The comamnd enters the
completion that you select in the source buffer. See Using
Minibuffer-Based Completion for more information.

@item jde-complete
This is the JDEE's user-definable "standard" completion command. It
delegates completion to one of the JDEE's other completion commands
(jde-complete-menu by default) or to a custom completion function that
you specify (@ref{Selecting a Completion Method} for more
information.) The @code{jde-complete command} is bound by default to
the key combination @kbd{C-c C-v C-.}. If you prefer another binding,
use the customization variable @code{jde-key-bindings} to change the
binding.
@end table

The JDEE's field and method completion commands use the Beanshell to
run Java code that in turn uses Java's reflection (class
introspection) capability to determine the fields and methods defined
for the class of object at point. The commands start the Beanshell if
it is not running. This can cause a noticeable delay in completion the
first time it is used in a session. The response can also be slow for
classes containing many methods and fields.

@indentedblock
Note: @ref{Speeding Up Completion} for some tips on how you can
dramatically speed up field and method completion.
@end indentedblock

Completion works only for compiled classes that reside in the
classpath defined by @code{jde-global-classpath}, if set, otherwise by
the @env{CLASSPATH} environment variable when the Beanshell
starts. Thus, if the JDEE is unable to complete a method or field,
make sure that the class that defines the field or method is compiled
and exists on the classpath defined by @code{jde-global-classpath}, if
set, otherwise by the @env{CLASSPATH} environment variable.

The JDEE completion commands work for all of the following cases:
@itemize
@item
objects referenced by variables declared in the current buffer

@item
static fields and methods

@item
fields and methods of objects defined by the current class and its
parent

Names of fields and methods of the current class must start with this
or . (period). Names of fields and methods declared by the parent of
the current class must start with super.

For example, this command completes:
@example
. ^ this. ^ super. ^
@end example

@item
objects referenced by the fields of objects referenced by variables
declared in the current class or its parent or by static fields

For example, this command completes:
@example
System.out.prin ^
@end example

@item
objects returned by methods of objects referenced by variables defined
in the current

For example, this command completes:
@example
Toolkit.getDefaultToolkit().get ^
@end example

@item
objects referenced by method parameters

For example, this command completes:
@example
void setColor(String color) @{ color.get ^ @}
@end example

@end itemize

@node Selecting a Completion Method, Using Menu-Based Completion, Completing Method and Field Names, Completing Expressions
@subsection Selecting a Completion Method

The JDEE's generic completion command, @code{jde-complete} delegates
completion to one of several specific completion commands supplied by
the JDEE or to a custom completion method that you supply. This allows
you to customize jde-complete to use the completion method that you
prefer.

To specify your preferred completion method:

@enumerate
@item
Type M-x jde-complete-function RET

@item
Select the completion command that implements the completion method
you prefer.

@item
If you selected Custom as your preferred completion function, enter
the name of the custom completion function in the adjacent edit field,
replacing the existing contents (ignore by default.).

@item
Save your selection in your .emacs or project file.
@end enumerate

@node Using Menu-Based Completion, Using In-Line Completion, Selecting a Completion Method, Completing Expressions
@subsection Using Menu-Based Completion

The jde-complete-menu displays a popup menu of completions for the
method or field name at point. Selecting a completion from the menu
causes the command to use it to complete the method or field at
point. This section assumes that you have selected jde-complete-menu
as your standard completion command.

To select completions from a menu:

@enumerate
@item
Position point immediately following the partially complete field or
method name.

@item
Type the @kbd{C-c C-v C-.} key combination.

@item
Select the desired completion from the menu.

@item
The JDEE inserts the completion at point in the buffer.
@end enumerate

@node Using In-Line Completion, Speeding Up Completion, Using Menu-Based Completion, Completing Expressions
@subsection Using In-Line Completion

The jde-complete-in-line command allows you to select completions at
the point of insertion in the source buffer. The command finds all the
fields and methods that complete the name at point. It then inserts
the first potential completion in the buffer at point. Repeatedly
executing the command causes the JDEE to cycle through the other
potential completions. If the completion is a method name, the command
completes the method name and displays the method signature in the
minibuffer.

The @code{jde-complete-in-line} command is bound to @kbd{C-c C-v
.}. You can use this combination to invoke the command or @kbd{C-c C-v
C-.}, if you have selected this command as your preferred completion
method. The following examples use the @kbd{C-c C-v .} combination.

Example: completing a String Method Name

Typing @kbd{C-c-C-v-.}

@example
String s; s.get ^
@end example

completes the method name at point as follows

@example
String s; s.getClass( ^
@end example

and displays

@example
java.lang.Class getClass()
@end example

in the minibuffer. Repeatedly typing @kbd{C-c-C-v-.} cycles through
all the other get methods for the Java String class.

@node Speeding Up Completion,  , Using In-Line Completion, Completing Expressions
@subsection Speeding Up Completion

Here are two ways you can significantly speed up field and method
completion:
@itemize

@item
Byte-compile the EIEIO and JDEE packages.

@item
The beanshell package, the Emacs interface to the BeanShell, is based
on the EIEIO object-oriented Lisp package for Emacs. Completion uses
the BeanShell heavily to determine the class of the field or method at
point. Thus compiling EIEIO and @file{beanshell.el} improves
completion's performance, dramatically in my tests.

@item
Import by class, not by package, in your Java files.

Every package import, e.g., @code{java.util.*}, requires invoking the
BeanShell to determine the fully qualified name of the class at point
(see jde-parse-get-qualified-name). A Beanshell invocation is by far
the most time-consuming operation required for completion. Thus
eliminating the use of package-level imports can significantly speed
up completion.
@end itemize

@node Dynamic Keyword Completion, Generating Code, Completing Expressions, User's Guide
@section Dynamic Keyword Completion

Emacs provides dynamic completion commands that attempt to find
completions for the word at point in the current buffer or other
buffers.

Example: Using Dynamic Completion

Suppose that the current source buffer contains the class names
Component and Container. Now suppose you enter Co somewhere in the
buffer and type @kbd{M-/}. The text Component replaces Co in the
buffer.

Typing @kbd{M-/} again changes Component to Container. In this way,
you can cycle through all the possible completions for Co in the
current buffer.

@menu
* Dynamic Completion Commands::
* Electric Return::
@end menu

@node Dynamic Completion Commands, Electric Return, Dynamic Keyword Completion, Dynamic Keyword Completion
@subsection Dynamic Completion Commands

Emacs provides two dynamic completion commands.

The @code{dabbrev-expand} command is bound to the key combination
@kbd{M-/} by default. It searches the current buffer for completions
of the word at point and, if none are found, other buffers of the same
type. For example, if the current buffer is a Java source buffer, it
searches other Java source buffers for completions if none are found
in the active buffer.

The @code{hippie-expand} command provides more extensive search
capabilities. See the docstrings for these functions for more
information.

@node Electric Return,  , Dynamic Completion Commands, Dynamic Keyword Completion
@subsection Electric Return

In electric return mode, pressing the @kbd{Enter} key causes the JDEE
to close open braces at the end of a line. To enable or disable this
mode by default, customize jde-electric-return-p.

To turn the mode on or off during a session, select JDE->Code
Generation->Modes->Electric Return.

@node Generating Code, Checking Coding Style, Dynamic Keyword Completion, User's Guide
@section Generating Code

The JDEE provides the following code generation capabilities.
    Code wizards
    Code templates

@menu
* Generating Import Statements::
* Code Wizards::
* Code Templates::
@end menu

@node Generating Import Statements, Code Wizards, Generating Code, Generating Code
@subsection Generating Import Statements

The JDEE provides a set of commands that generate and organize import
statements in the current buffer. The commands automate the following
tasks:

@menu
* Importing Classes::           Generate an import statement for the class at point
* Importing All Classes::       Generate import statements for all classes in the current buffer that need import statements
* Expanding Package Imports::   Expand a package import statement into specific class imports
* Collapsing Class Imports::    Collapse class imports into a package import statement
* Grouping Imports::            Group import statements
* Deleting Unneeded Imports::   Delete superfluous import statements
@end menu

@node Importing Classes, Importing All Classes, Generating Import Statements, Generating Import Statements
@subsubsection Importing Classes

The JDE->Import->Class  (jde-import-find-and-import, C-c C-v C-z)
command generates an import statement for the class at point in the
current buffer. It inserts the import statement at the head of the
buffer.

This command uses the BeanShell to search the classpath of the current
project for classes that match the name of the class at point. The
class name may be unqualified.

@indentedblock
Note: The classpath that the import wizard searches for import
candidates is the classpath specified by the value of
jde-global-classpath for the current project.
@end indentedblock

If the command finds more than one class of the same unqualified name
on the current classpath, it prompts you to select one of the classes
to import.

The customization variable jde-import-excluded-classes allows you to
specify rules for excluding classes from consideration for import into
the current source file. If the import command finds any classes on
the classpath that belong to the list of prohibited classes, it
removes them from the list of classes considered for import into the
current buffer.

You can use either regular expressions or Lisp functions to specify
class exclusion rules. For each rule, you can also specify that all
classes whose unqualified names match the rule be excluded from
consideration for import. This is useful for preventing the JDEE from
importing alternate implementations of standard Java classes that do
not need to be imported.

For example, the default setting for jde-import-excluded-classes
includes a rule to exclude all classes belonging to the java.lang
package because every Java class implicitly imports this package. The
default setting for jde-import-excluded-classes also excludes all
unqualified synonyms of classes belonging to the java.lang
package. This prevents importation of alternate implementations of
these classes, e.g., alternate implementations of java.lang.String,
included in some commonly used class libraries and intended for
internal use. See the docstring for jde-import-excluded-classes for
more information.

Thanks to Len Trigg for contributing the initial implementation of the
import wizard and to Martin Schwarmberger for significantly enhancing
the import wizard.

@node Importing All Classes, Expanding Package Imports, Importing Classes, Generating Import Statements
@subsubsection Importing All Classes

The JDE->Code Generation->Import->All (jde-import-all, C-c C-v z)
imports all the classes that need to be imported into the current
buffer.

The command imports all classes that meet the following conditions:
@itemize
@item
The class's base name begins with an uppercase letter.

@item
The class's base name contains at least one noninitial lowercase
letter.

@item
The class is not already imported into the buffer.

@item
The class is not in jde-import-excluded-classes.

@item
The class exists on the current classpath.
@end itemize

If more than one import candidate with the same base name exists on
the classpath, the JDEE displays a dialog that allows you to select
one of the candidates.

@indentedblock
Note: You can use the JDE->Code Generation->Import->Import All Unique
(jde-import-all-unique ) command to avoid the dialog box. This command
imports all classes whose unqualified names appear only once on the
classpath.
@end indentedblock

Thanks to Phillip Lord for contributing the initial implementation of
the Import All Wizard.

@node Expanding Package Imports, Collapsing Class Imports, Importing All Classes, Generating Import Statements
@subsubsection Expanding Package Imports

To expand a package import statement, select JDE->Code
Generation->Import->Expand Package Imports
(jde-import-expand-imports). This command replaces a package import
statement, e.g.:

@example
import java.io.*;
@end example

with import statements for the members of that package referenced by
the current buffer, e.g.:

@example
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
@end example

@node Collapsing Class Imports, Grouping Imports, Expanding Package Imports, Generating Import Statements
@subsubsection Collapsing Class Imports

To collapse class import statements in the current buffer into package
imports, select JDE->Code Generation->Import->Collapse Class Imports
(jde-import-collapse-imports). This command collapses imports for any
package that contains as many as or more than the number of imports
specified by jde-import-collapse-imports-threshhold. The default value
of this variable is 2. This causes this command to collapse imports
for any package from which the current buffer imports two or more
classes. For example, this command, by default, collapses:

@example
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
@end example

to

@example
import java.io.*;
@end example

@node Grouping Imports, Deleting Unneeded Imports, Collapsing Class Imports, Generating Import Statements
@subsubsection Grouping Imports

To organize import statements into groups of related imports, select
JDE->Code Generation->Import->Organize Imports
(jde-import-organize). By default this command groups import
statements into two groups separated by a blank line. The first group
contains all imports from the java and javax packages. The other group
contains imports from all other packages. The imports are sorted
alphabetically in ascending order in each group, e.g.:

@example
import java.io.InputStreamReader;
import java.util.Hashtable;
import javax.swing.JFrame;
import javax.swing.JPanel;

import jmath.LinearSystem;
import jmath.Test;
@end example

The following variables allow you to customize the organization of
imports into groups:

@table @code
@item jde-import-group-function
This variable allows you to specify a function that assigns imports to
groups. The default group function is jde-import-group-of, which uses
rules specified by the following variable to assign imports to
groups.

@item jde-import-group-rules
This variable specifies a list of rules for assigning import
statements to group, e.g., '(("^javax\\." . "Swing")), Each rule
consists of two parts: a regular expression and an optional group name
specifier. The jde-import-group-of function assigns an import
statement to the group if it matches the regular expression. The group
name specifier is either a string that specifies the name or an index
to a component of the regular expression to be used as the group
name.

@item jde-import-insert-group-names
Specifies whether to insert an import group's name in the buffer.

@item jde-import-default-group-name
Specifies the default name for an import group.

@item jde-import-blank-line-between-groups
Specifies whether to insert a blank line between import groups.

@item jde-import-sorted-groups
Specifies whether and how to sort groups of packages. Options include
no sorting, in the order specified by grouping rules, or in ascending
or descending alphabetical order.
@end table

@node Deleting Unneeded Imports,  , Grouping Imports, Generating Import Statements
@subsubsection Deleting Unneeded Imports

To delete superfluous import statements from the current buffer,
select JDE->Code Generation->Import->Delete Unneeded
(jde-import-kill-extra-imports). This command deletes all import
statements for classes that are not actually referenced by the class
in the current buffer.

@node Code Wizards, Code Templates, Generating Import Statements, Generating Code
@subsection Code Wizards

The JDEE provides a set of procedural code generators called code
wizards. They include:


Method Override Wizard
A method that overrides a method inherited by the class containing point.

Interface Wizard
Implementation of an interface in the class containing point.

Delegate Wizard
Methods that delegate tasks to a specified class.

Abstract Class Wizard
Implementations of the abstract methods inherited by the class containing point.

Get/Set Wizard
Get and set methods for the private fields of the class containing point.

@indentedblock
Note: Some of the wizards use the BeanShell to run Java code. A wizard
starts the Beanshell interpreter if it is not already running. Thus,
you may experience a slight delay when invoking a wizard for the first
time in a session.
@end indentedblock

@menu
* Method Override Wizard::
* Interface Wizard::
* Delegate Wizard::
* Get/Set Wizard::
@end menu

@node Method Override Wizard, Interface Wizard, Code Wizards, Code Wizards
@subsubsection Method Override Wizard
The method override wizard generates a skeleton method that overrides
a similarly named method defined by a superclass.

To override a method of a superclass:
@enumerate
@item
Position the Emacs point at the location in the buffer where you want
the generated method to appear.

The point must be within the class that is overriding the method.

@item
Select Wizards->Override Method from the JDEE menu or enter M-x
jde-wiz-overrided-method.

The JDEE prompts you to enter the name of the method to be overridden
in the minibuffer.

The name must be the name of a method defined by an ancestor of the
class in which the Emacs point is located. The compiled class of the
ancestor must be on the classpath specified by jde-global-classpath.

@item
Enter the name of the method to be overridden.

If the ancestors of the class in which you are overriding the method
define more than one method of the same name, the wizard displays a
dialog buffer that lists the methods. For example, Java's awt class
hierarchy defines several variants of the method repaint. If you
specify repaint as the method to override, the JDEE displays a dialog
buffer.

The dialog buffer lists the signature of each variant of the method
you specified. Next to each signature is a radio button. The radio
button of the currently selected signature contains an asterisk. To
select another signature, right-click the radio button next to the
variant. To confirm your selection and dismiss the dialog, right-click
the [Ok] button.

@item
Select the method variant you want to override and click the [Ok]
button.

The wizard inserts a skeleton implementation of the selected method at
the current point in the Java source buffer.

The wizard also inserts import statements for any classes referenced
by the method that are not already imported by the containing class
either explicitly or implicitly. The wizard inserts the import
statements at the head of the source buffer after any existing import
statements, or any package statement, or the first blank line in the
buffer.
@end enumerate

@indentedblock
Note: The method override wizard uses the BeanShell to create the
interface implementation. If the BeanShell is not currently running,
the wizard starts the BeanShell. Thus, if the BeanShell is not already
running, you may experience a short pause the first time you override
a method.
@end indentedblock

@node Interface Wizard, Delegate Wizard, Method Override Wizard, Code Wizards
@subsubsection Interface Wizard

This wizard creates a skeleton implementation of any interface defined
on the classpath specified by jde-global-classpath.

To create an implementation of an interface:
@enumerate
@item
If the interface is to be implemented by a new class, create the class
in a buffer.

@item
Position the Emacs point at the point in the class where you want the
implementation of the interface's methods to appear.

@item
Select JDE->Wizards->Implement Interface or enter M-x
jde-wiz-implement-interface.

The JDEE prompts you to enter the name of the interface to be
implemented.

@item
Enter the fully qualified name of the interface, for example,
java.awt.Event.MouseListener.

The wizard inserts skeleton implementations of the methods declared by
the interface at the current point in the current buffer. It inserts
import statements for any classes required by the interface at the
head of the current buffer (only if import statements do not already
exist for the required classes). It also updates or creates an
implements clause for the class.
@end enumerate

@indentedblock
Note: The interface wizard uses the BeanShell to create the interface
implementation. If the BeanShell is not currently running, it starts
the BeanShell. Thus, if the BeanShell is not already running, you may
experience a short pause the first time you use the wizard.
@end indentedblock

Thanks to Eric Friedman for creating the framework for the interface,
method override, and abstract class wizards and for contributing the
initial implementation of the interface wizard.

@node Delegate Wizard, Get/Set Wizard, Interface Wizard, Code Wizards
@subsubsection Delegate Wizard

This wizard generates methods that delegate calls to a class in the
current buffer to an attribute of the class, i.e., to an object that
is a field of the current class. For example, if the current buffer
contains class A and A has an attribute, A.b, that is an instance of
class B, this wizard generates all the public methods of class B in A
and delegates handling of those methods to b.

Thanks to Charles Hart for contributing this wizard.

@node Get/Set Wizard,  , Delegate Wizard, Code Wizards
@subsubsection Get/Set Wizard

This wizard generates get and set methods for the private fields of
the class at point, but only if the fields do not already have get or
set methods. To generate the methods, move point to the point in the
class where you want the get and set methods to appear. Then select
JDE->Code Generation->Wizards->Generate Get/Set Methods... or enter
M-x jde-wiz-get-set-methods

Thanks to Javier Lopez and Sandip Chitale for contributing this
wizard.

@node Code Templates,  , Code Wizards, Generating Code
@subsection Code Templates

@menu
* Buffer Templates::
* Specifying Boilerplate Text::
* Customization Variables::
* Point Templates::
* Customizing Templates::
* Creating Templates::
* Defining a Template and Template Insertion Function::
* Registering Custom Templates::
* Assigning Keys to Templates::
@end menu

@node Buffer Templates, Specifying Boilerplate Text, Code Templates, Code Templates
@subsubsection Buffer Templates

These commands create buffers containing a skeleton Java class. Each
command prompts you to enter the path to a new Java source file. They
then create a buffer for the new file and insert a template for a
class of the same name as the newly created file. In particular, the
command:

@table @code
@item Files->JDE New->Class
creates a buffer containing a generic Java public class

@item Files->JDE New->Console
creates a buffer containing the main class of a Java console
application

@item Files->JDE New->Other
prompts you to create any of the above buffers or a custom
(user-defined) buffer.
@end table

You can create an empty Java class buffer by selecting Files->Open
(C-x f) and entering the path for a new file whose root name is the
same as the class you want to create and whose extension is .java.

@node Specifying Boilerplate Text, Customization Variables, Buffer Templates, Code Templates
@unnumberedsubsubsec Specifying Boilerplate Text

You can specify boilerplate text (for example, a copyright notice) to
be inserted at the head of class source files created by the JDE. The
JDEE provides two ways to specify the boilerplate text. The simplest
way is to enter the lines of boilerplate text as the value of the
customization variable jde-gen-buffer-boilerplate. Another way to
specify the text is to set the value of the customization variable
jde-gen-boilerplate-functionto a function that generates the
boilerplate text. (The default value of this variable is
jde-gen-create-buffer-boilerplate, which returns the value of the
boilerplate variable, jde-gen-buffer-boilerplate). The functional
approach allows you to generate boilerplate text dynamically by
evaluating the appropriate Lisp code. By saving the values of
boilerplate variables in project files, you can specify different
boilerplate text for each project.

@node Customization Variables, Point Templates, Specifying Boilerplate Text, Code Templates
@unnumberedsubsubsec Customization Variables

The following JDEE customization variables control creation of
autocoded Java source buffers:

@multitable @columnfractions .45 .15 .40
@headitem Variable @tab Group @tab Usage
@item jde-gen-class-buffer-template @tab Autocode @tab Template for a generic public class buffer.
@item jde-gen-console-buffer-template @tab Autocode @tab Template for a console application buffer.
@item jde-gen-jfc-app-buffer-template @tab Autocode @tab Template for a JFC (Swing) application.
@item jde-gen-junit-test-class-buffer-template @tab Autocode @tab Template for a JUnit test case class. This template requires the JUnit test framework.
@item jde-gen-buffer-templates @tab Autocode @tab Specifies templates available to create Java buffers.
@item jde-gen-buffer-boilerplate @tab Autocode @tab Specifies lines of text to be inserted at the head of class files.
@item jde-gen-boilerplate-function @tab Autocode @tab Specifies a function that returns a string of boilerplate text. The default value is jde-gen-create-buffer-boilerplate, which returns the value of jde-gen-buffer-boilerplate.
@end multitable

See Customizing Templates for information on how to customize the
class creation templates.

@node Point Templates, Customizing Templates, Customization Variables, Code Templates
@subsubsection Point Templates

The following commands insert templates at the current point in the
buffer:

@table @asis
@item JDE->Generate->Get/Set Pair
generates an instance variable and a get and set method for that
variable

@item JDE->Generate->Println
generates a @code{System.out.println(...);} statement.

@item JDE->Generate->Action
generates and registers an action listener for a specified component.

@item JDE->Generate->Listener->Window
generates and registers a window listener for a specified window.

@item JDE->Generate->Listener->Mouse
generates and registers a mouse listener for a specified component.

@item JDE->Generate->Other
allows you to select any of the above templates or a custom
(user-defined) template.
@end table

The following variables control generation of code at point:

@multitable @columnfractions .45 .15 .40
@headitem Variable @tab Group @tab Usage
@item jde-gen-get-set-var-template @tab Autocode @tab Defines a get/set method pair template.
@item jde-gen-listener-action-template @tab Autocode @tab Defines an action listener template.
@item jde-gen-listener-window-template @tab Autocode @tab Defines a window listener template.
@item jde-gen-listener-mouse-template @tab Autocode @tab Defines a mouse listener template.
@item jde-gen-inner-class-template @tab Autocode @tab Defines a template for creating a class inside another class or inside an existing source buffer.
@item jde-gen-code-templates @tab Autocode @tab Specifies available code templates.
@end multitable

See @ref{Customizing Templates} for information on how to customize
templates provided by the JDEE.

@ref{Creating Templates} for information on how to create templates
from scratch.

@node Customizing Templates, Creating Templates, Point Templates, Code Templates
@subsubsection Customizing Templates

You can customize the JDEE's standard code templates, using the Emacs
customization feature.

To customize an autocode template:
@enumerate
@item
Select JDE->Options->Autocode

The JDEE displays a customization buffer containing the autocode
templates.

@item
Edit the template to suit your needs.

The JDEE uses the template format defined by tempo.el to represent
class templates. Each template consists of a list of strings, symbols,
and functions, each of which represents content to be inserted
successively into the buffer at the current point. The strings
represent fixed content. The symbols and functions represent variable
content. See the docstring for the function tempo-define-template for
more information, including the meaning of special symbols such as
@code{'n}.

@item
Select the state button associated with the template.

A menu pops up with a list of options for saving your changes.

@item
Save your changes.
@end enumerate

Select Save for Future Sessions if you want your changes to apply to
all projects. If you want your changes to apply only to the current
projects, select Set for Current Session. Then select
JDE->Options->Save Project to save your changes in the current
project's project file.

@node Creating Templates, Defining a Template and Template Insertion Function, Customizing Templates, Code Templates
@subsubsection Creating Templates

The JDEE considers any command (interactive function) that inserts
code into a buffer at point to be a template. The JDEE uses the Emacs
tempo library to create built-in templates. You can use tempo to
create your own, add-on templates (see below and the doc for the
tempo-define-template for more information) or create templates from
scratch. In either case, once you have created a template, you can add
it to the JDE's lists of available code and/or buffer templates, using
the JDEE's jde-gen-code-templates and/or jde-gen-buffer-templates
variables, respectively. Adding a template to these lists enables you
to invoke the templates from the JDEE menus. When adding a template,
you need to specify a unique title for the template. These titles
enable you to specify the templates when invoking them, using the
JDE's custom code template commands (Files->JDE New->Custom and
JDE->Generate->Custom). You can use auto completion to enter a
template title when invoking a custom code generation command. Note
that you can specify different sets of templates for different
projects, by setting and saving the template list variables in project
files. See the following sections for more information:

@node Defining a Template and Template Insertion Function, Registering Custom Templates, Creating Templates, Code Templates
@unnumberedsubsubsec Defining a Template and Template Insertion Function

The tempo-define-template macro enables you to define a template and a
function that inserts that template at the current point in the
current buffer. You specify the template as a list oftemplate elements
where each element is text, a special symbol, or a Lisp
expression. The function inserts each text element exactly as
specified in the buffer; it replaces special symbols with some text
(e.g., user input), and it replaces Lisp expressions with the text
that results from evaluating them.

For example, the following Lisp code:

@example
(tempo-define-template "foo"
;; template name
'("System.out.println(\"foo\");")
;;template definition "f"
;; abbreviation "Inserts a print foo message")
;; template documentation
@end example

defines a template for Java code that always prints "foo" to standard
out:

@example
System.out.println("foo");
@end example

Notice that the template definition uses the Lisp string escape
character to specify the string "foo". This is necessary when you want
to include quoted strings in a template definition.

The sample Lisp form also defines an interactive template function
tempo-template-foo. Now suppose you insert the sample code in your
.emacs file. After Emacs starts up, whenever you enter the command M-x
tempo-template-foo, Emacs inserts:

@example
System.out.println("foo");
@end example

at the current point in your Java source buffer (or any buffer, tempo
doesn't care).

The preceding example is admittedly not vary useful because it always
prints the same text. You can create more useful templates, using
special tempo template symbols and lisp forms. This approach, for
example, allows you to create a template that can print any
user-defined text to standard out:

@example
(tempo-define-template "debug"
;; template name '("if (debug)" n>
;; insert new line plus indent
"System.out.println(" (p "Enter debug message:")       ;; Prompts for debug message
");") "d"
;; abbreviation "Inserts a print debug message")
;; template documentation
@end example

The template function produced by this example prompts you to enter
the text to be printed when inserting the function into a buffer. In
particular, it inserts:

@example
if (debug) System.out.println(DEBUG-MESSAGE);
@end example

where DEBUG-MESSAGE is any text that you enter. For example, suppose
you enter:

@example
"Selected color = " + color
@end example

at the prompt. The template function inserts:

@example
if (debug) System.out.println("Selected color = " + color);
@end example

at the current point in the buffer.

See the documentation for tempo-define-template (type c-h f
tempo-define-template) for more information on creating templates.

@node Registering Custom Templates, Assigning Keys to Templates, Defining a Template and Template Insertion Function, Code Templates
@unnumberedsubsubsec Registering Custom Templates

You can register templates that you create with the JDEE. When you
register a template with the JDEE, it appears among the list of
templates that you can select when you select
JDE->Generate->Other.....

You register a template by customizing the JDEE variable
jde-gen-code-templates. The value of this variable is a list of the
template functions that the JDEE command JDE->Generate->Other.... can
invoke.

To register a custom template, add its name to the list.

To insert a template that you have registered:

@enumerate
@item
Select JDE->Generate->Other....

The JDEE displays the prompt @code{Enter template:} in the
minibuffer.

@item
Enter the template's name and press Enter or press the Tab key to
display a list of templates in a completion buffer:

@item
Select the template you want by double-clicking its name.
@end enumerate

@node Assigning Keys to Templates,  , Registering Custom Templates, Code Templates
@unnumberedsubsubsec Assigning Keys to Templates

You can assign templates to keyboard keys to speed use of frequently
used templates. For example, insert this form:

@example
(global-set-key [f9] 'jde-gen-to-string-method)
@end example

in your .emacs file to assign the @kbd{F9} function key to the JDEE
template that generates a skeleton toString method.

@node Checking Coding Style,  , Generating Code, User's Guide
@section Checking Coding Style

The JDE->Check Style command (M-x jde-checkstyle) command checks the
current buffer for conformity to a Java coding standard. The default
standard is that specified by Oracle. Execute jde-checkstyle-customize
to customize the command to support your own coding standard.

The command displays a list of stylistic faults in a popup
buffer. Click the error message to display the line that violates the
standard.

@c @node Compiling


@node Developer's Guide, Index, User's Guide, Top
@chapter Developer's Guide

@menu
* JDEE Components::             Describes parts of JDEE
@end menu

@node JDEE Components,  , Developer's Guide, Developer's Guide
@section JDEE Components

@cindex chapter, first

The JDEE distribution includes the following files:
@itemize

@item
@file{jde.el} Defines jde-mode, a major Emacs mode for developing Java code.

@item
@file{jde-run.el} Runs Java applications and applets

@item
@file{jde-db.el} Interfaces Emacs to jdb, the command-line debugger that comes with the JDK.

@item
@file{jde-gen.el} Contains code generation templates.

@item
@file{bsh.jar} Compiled files for the BeanShell, a Java source code interpreter developed by Pat Neimeyer.

@item
@file{beanshell.el} Provides an Emacs interface to the BeanShell interpreter.

@item
@file{jde-wiz.el} Provides "wizards" that generate skeleton implementations of interfaces and skeleton overrides of methods declared by superclasses.

@item
@file{jde-complete.el} Automatic field and method completion package.

@item
@file{jde-parse.el} Java parser package.

@item
@file{java.bnf} Java grammar used to generate the JDEE's lisp-based Java parser.

@item
@file{jde-bug.el} JDEbug user interface package.

@item
@file{jde-dbs.el} JDEbug low-level command interface package.

@item
@file{jde-dbo.el} JDEbug output processing functions.

@item
source code, jar files, and documentation for the Java components of the JDEE.

@item
@file{jtags} is a bash shell script that tags Java source hierarchies.

@item
@file{jtags.csh} is a c shell script that tags Java source heierarchies.

@end itemize

@node Index,  , Developer's Guide, Top
@unnumbered Index

@printindex cp

@bye
